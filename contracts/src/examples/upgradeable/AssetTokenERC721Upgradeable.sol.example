// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// NOTE: This contract requires OpenZeppelin's upgradeable contracts library
// Install via: forge install OpenZeppelin/openzeppelin-contracts-upgradeable
// Then add to remappings: @openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/

import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "../IFixDescriptor.sol";
import "../FixDescriptorLib.sol";

/**
 * @title AssetTokenERC721Upgradeable
 * @notice Example upgradeable ERC721 NFT with embedded FIX descriptor
 * @dev Demonstrates how to integrate FixDescriptor into an upgradeable ERC721 token using UUPS pattern
 *      Uses FixDescriptorLib for maximum flexibility with upgradeable contracts
 *      This example uses a single descriptor for the entire collection.
 *      For per-token descriptors, use mapping(uint256 => FixDescriptorLib.Storage)
 */
contract AssetTokenERC721Upgradeable is 
    Initializable,
    ERC721Upgradeable,
    OwnableUpgradeable,
    UUPSUpgradeable,
    IFixDescriptor 
{
    using FixDescriptorLib for FixDescriptorLib.Storage;

    /// @notice FIX descriptor storage for this collection
    FixDescriptorLib.Storage private _fixDescriptor;

    /// @notice Next token ID to mint
    uint256 private _nextTokenId;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @notice Initialize the contract
     * @param name Token name
     * @param symbol Token symbol
     */
    function initialize(
        string memory name,
        string memory symbol
    ) public initializer {
        __ERC721_init(name, symbol);
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
    }

    /**
     * @notice Mint a new token
     * @param to Address to mint to
     * @return tokenId The minted token ID
     */
    function mint(address to) external onlyOwner returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
        return tokenId;
    }

    /**
     * @notice Set the FIX descriptor for this collection
     * @dev Can only be called by owner. Emits appropriate event.
     * @param descriptor The complete FixDescriptor struct
     */
    function setFixDescriptor(FixDescriptor calldata descriptor) external onlyOwner {
        _fixDescriptor.setDescriptor(descriptor);
    }

    /**
     * @inheritdoc IFixDescriptor
     */
    function getFixDescriptor() external view override returns (FixDescriptor memory) {
        return _fixDescriptor.getDescriptor();
    }

    /**
     * @inheritdoc IFixDescriptor
     */
    function getFixRoot() external view override returns (bytes32) {
        return _fixDescriptor.getRoot();
    }

    /**
     * @inheritdoc IFixDescriptor
     */
    function verifyField(
        bytes calldata pathCBOR,
        bytes calldata value,
        bytes32[] calldata proof,
        bool[] calldata directions
    ) external view override returns (bool) {
        return _fixDescriptor.verifyFieldProof(pathCBOR, value, proof, directions);
    }

    /**
     * @notice Get CBOR data chunk
     * @param start Start offset (in the data, not including STOP byte)
     * @param size Number of bytes to read
     * @return chunk The requested CBOR data
     */
    function getFixCBORChunk(uint256 start, uint256 size)
        external
        view
        returns (bytes memory chunk)
    {
        return _fixDescriptor.getFixCBORChunk(start, size);
    }

    /**
     * @inheritdoc IFixDescriptor
     */
    function getHumanReadableDescriptor() external view override returns (string memory) {
        return _fixDescriptor.getHumanReadable();
    }

    /**
     * @dev Function that should revert when msg.sender is not authorized to upgrade the contract.
     */
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    /**
     * @inheritdoc IERC165
     */
    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        virtual 
        override(ERC721Upgradeable) 
        returns (bool) 
    {
        return interfaceId == FixDescriptorLib.getInterfaceId() || 
               interfaceId == type(IFixDescriptor).interfaceId ||
               super.supportsInterface(interfaceId);
    }

    /**
     * @dev Storage gap for future upgrades
     */
    uint256[48] private __gap;
}

