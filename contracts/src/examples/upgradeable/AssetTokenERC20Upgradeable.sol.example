// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// NOTE: This contract requires OpenZeppelin's upgradeable contracts library
// Install via: forge install OpenZeppelin/openzeppelin-contracts-upgradeable
// Then add to remappings: @openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "../IFixDescriptor.sol";
import "../FixDescriptorLib.sol";

/**
 * @title AssetTokenERC20Upgradeable
 * @notice Example upgradeable ERC20 token with embedded FIX descriptor
 * @dev Demonstrates how to integrate FixDescriptor into an upgradeable ERC20 token using UUPS pattern
 *      Uses FixDescriptorLib for maximum flexibility with upgradeable contracts
 */
contract AssetTokenERC20Upgradeable is 
    Initializable,
    ERC20Upgradeable,
    OwnableUpgradeable,
    UUPSUpgradeable,
    IFixDescriptor 
{
    using FixDescriptorLib for FixDescriptorLib.Storage;

    /// @notice FIX descriptor storage
    FixDescriptorLib.Storage private _fixDescriptor;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @notice Initialize the contract
     * @param name Token name
     * @param symbol Token symbol
     * @param initialSupply Initial token supply
     * @param initialOwner Address to receive initial supply and ownership
     */
    function initialize(
        string memory name,
        string memory symbol,
        uint256 initialSupply,
        address initialOwner
    ) public initializer {
        __ERC20_init(name, symbol);
        __Ownable_init(initialOwner);
        __UUPSUpgradeable_init();
        
        _mint(initialOwner, initialSupply);
    }

    /**
     * @notice Set the FIX descriptor for this asset
     * @dev Can only be called by owner. Emits appropriate event.
     * @param descriptor The complete FixDescriptor struct
     */
    function setFixDescriptor(FixDescriptor calldata descriptor) external onlyOwner {
        _fixDescriptor.setDescriptor(descriptor);
    }

    /**
     * @inheritdoc IFixDescriptor
     */
    function getFixDescriptor() external view override returns (FixDescriptor memory) {
        return _fixDescriptor.getDescriptor();
    }

    /**
     * @inheritdoc IFixDescriptor
     */
    function getFixRoot() external view override returns (bytes32) {
        return _fixDescriptor.getRoot();
    }

    /**
     * @inheritdoc IFixDescriptor
     */
    function verifyField(
        bytes calldata pathCBOR,
        bytes calldata value,
        bytes32[] calldata proof,
        bool[] calldata directions
    ) external view override returns (bool) {
        return _fixDescriptor.verifyFieldProof(pathCBOR, value, proof, directions);
    }

    /**
     * @notice Get CBOR data chunk
     * @param start Start offset (in the data, not including STOP byte)
     * @param size Number of bytes to read
     * @return chunk The requested CBOR data
     */
    function getFixCBORChunk(uint256 start, uint256 size)
        external
        view
        returns (bytes memory chunk)
    {
        return _fixDescriptor.getFixCBORChunk(start, size);
    }

    /**
     * @inheritdoc IFixDescriptor
     */
    function getHumanReadableDescriptor() external view override returns (string memory) {
        return _fixDescriptor.getHumanReadable();
    }

    /**
     * @dev Function that should revert when msg.sender is not authorized to upgrade the contract.
     */
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    /**
     * @inheritdoc IERC165
     */
    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        virtual 
        override 
        returns (bool) 
    {
        return interfaceId == FixDescriptorLib.getInterfaceId() || 
               interfaceId == type(IFixDescriptor).interfaceId ||
               super.supportsInterface(interfaceId);
    }

    /**
     * @dev Storage gap for future upgrades
     */
    uint256[49] private __gap;
}

